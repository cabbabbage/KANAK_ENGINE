# Kanak – Custom 2D Game Engine

## 1. Engine Core (C++ / SDL2)
The runtime engine (`engine.cpp`) is the entry point that loads map data, procedural room layouts, and all game assets, then enters the main loop for rendering and updating.

### Key Components
**Asset Loading:**
- `AssetLoader` reads `map_info.json`, parses layered room configurations, and spawns rooms and trails procedurally using `GenerateRooms`.
- Loads and instantiates `AssetInfo` for each asset, including animations, lights, and collision areas.
- Generates a minimap dynamically from room geometry.

**Main Loop:**
- Updates active assets via `Assets` and `ActiveAssetsManager` (distance-based activation).
- Calls `SceneRenderer` to draw the scene each frame.

---

## 2. Procedural Generation
Procedural room & trail placement is driven by JSON map definitions:
- **Layer specs** (radius, min/max rooms) define how rooms are arranged concentrically around a central spawn.
- **RoomSpecs** include asset types, instance counts, and required children.
- `GenerateRooms` builds a connected set of rooms/trails using sector-based placement so rooms don’t overlap and trails link clusters.

Rooms store their `Area` geometry (irregular circles/squares or loaded polygons), which is used for:
- Collision detection
- Rendering bounds
- Spatial queries

---

## 3. Asset Management
Assets are the in-game entities.

**`AssetInfo` (metadata):**
- Loads animation frames from disk or cache (via `Animation`).
- Defines light sources (point or orbital), shading, collision, interaction, and child asset data.
- Caches collision/spacing/interactivity areas.

**`Asset` (runtime instance):**
- Tracks position, animation state, children, Z-index sorting.
- Can attach multiple static light sources that affect other assets.

**`Assets` container:**
- Holds all loaded assets, tracks the player, runs movement/collision checks.
- Calls `set_static_lights()` to distribute baked lights to nearby shaded assets.

---

## 4. Active Asset Culling
`ActiveAssetsManager` maintains a minimal list of assets for rendering based on the camera’s position.
- Uses chunk-based spatial partitioning for static assets and per-frame updates for moving entities.
- Activates assets in the visible range and recursively activates children.

---

## 5. Rendering Pipeline
Handled by `SceneRenderer`.

**Main Map Light (`Generate_Map_Light`):**
- Creates a large elliptical or circular base light texture with radial fade and color gradients over time.
- Orbits around the scene, simulating sun/moon position.
- Alpha varies with horizon position (day/night fade).

**Dynamic Lights:**
- Per-asset lights from `LightSource` definitions.
- Orbital lights tied to rotation around a host asset (using `x_radius` / `y_radius` for elliptical paths).

**Shading Masks:**
- For shaded assets, a mask texture is regenerated when lighting changes or the asset animates.
- Mask blends main light, static lights, and player’s carried light.

**Z-layered Light Rendering:**
- Lights are collected and rendered in a depth-sorted batch (`render_asset_lights_z`).

**Minimap Rendering:**
- Drawn from room/trail bounds scaled to a small texture.

---

## 6. Lighting System
**Static lights:**
- Generated once from asset definitions.
- Distributed to nearby shaded objects within a radius.

**Dynamic lights:**
- Flicker, fade, and move relative to their owner each frame.

**Orbital lights:**
- Follow an elliptical path based on main light source’s angle.

**Custom light textures:**
- Generated by `GenerateLight` with configurable intensity, fall-off, flare size, and color.
- Cached to disk for reuse.

---

## 7. Python Game_Manager
Python/Tkinter tool used for:
- Creating and editing `info.json` for each asset.
- Designing collision/interactivity areas visually.
- Managing animations and scaling.
- Exporting area JSON used by the C++ `Area` class.
- Editing procedural map JSON (`map_info.json`) that feeds into `AssetLoader`.

---

## 8. Custom Shaders & Special Effects
Implemented in pure SDL2 (software blend modes) rather than GLSL:
- Uses blend modes (`SDL_BLENDMODE_ADD`, `MOD`, etc.) to simulate additive lighting and multiplicative shading.
- Procedural texture generation for lights and shadows replaces traditional fragment shaders.
- Orbital light rendering acts like a shader-driven spotlight but in software.

---
